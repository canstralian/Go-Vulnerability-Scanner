package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"text/template"
)

type ScanFinding struct {
	Vulnerability string
	AffectedHosts []string
	File          string
	Line          int
	Message       string
}

func main() {
	// Use the values for SonarCloud integration
	projectKey := os.Getenv("project_key")
	organizationKey := os.Getenv("organization_key")

	fmt.Println("SonarCloud Project Key:", projectKey)
	fmt.Println("SonarCloud Organization Key:", organizationKey)
	fmt.Println("SonarCloud Host:", os.Getenv("sonar_host"))
	fmt.Println("SonarCloud Token:", os.Getenv("sonar_token"))

	// Step 1: Select and configure the scanning tool
	scanningTool := "sample_tool"
	scanOptions := "--scan-options" // Replace with the appropriate command-line options for your selected scanning tool

	// Step 2: Execute the scanning tool as a separate process
	cmd := exec.Command(scanningTool, scanOptions)

	// Step 3: Parse the raw output from the scanning tool
	output, err := cmd.Output()
	if err != nil {
		log.Fatal(err)
	}

	// Step 4: Extract relevant data from the output using regular expressions
	findings := extractFindings(string(output))

	// Step 5: Generate a user-friendly report
	report := generateReport(findings)

	// Step 6: Save the report to a file
	err = saveReportToFile(report, "report.txt")
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Scan report generated successfully.")
}

func extractFindings(output string) []ScanFinding {
	// Use regular expressions to extract relevant information from the output
	vulnRegex := regexp.MustCompile(`Vulnerability: (.+)`)
	hostsRegex := regexp.MustCompile(`Affected Hosts: (.+)`)
	findingsRegex := regexp.MustCompile(`(?m)^\s*(?P<file>.*):(?P<line>\d+):\s*(?P<message>.*)`)

	// Extract the findings and store them in a slice of ScanFinding structs
	findings := []ScanFinding{}

	// Split the output by a delimiter specific to the scanning tool
	scanOutputs := strings.Split(output, "=======ENDOFLINE=======")

	// Iterate over the scanOutputs and extract the findings
	for _, scanOutput := range scanOutputs {
		// Extract the vulnerability information using regular expressions
		vulnMatches := vulnRegex.FindStringSubmatch(scanOutput)
		if len(vulnMatches) < 2 {
			continue // Skip if the vulnerability information is not found
		}

		finding := ScanFinding{
			Vulnerability: vulnMatches[1],
		}

		// Use the findingsRegex to extract file, line, and message
		findingsMatches := findingsRegex.FindStringSubmatch(scanOutput)
		if len(findingsMatches) >= 4 {
			file := findingsMatches[1]
			line, _ := strconv.Atoi(findingsMatches[2])
			message := findingsMatches[3]

			finding.File = file
			finding.Line = line
			finding.Message = message
		}

		// Extract the affected hosts using regular expressions
		hostsMatches := hostsRegex.FindStringSubmatch(scanOutput)
		if len(hostsMatches) >= 2 {
			hosts := strings.Split(hostsMatches[1], ",")
			for _, host := range hosts {
				host = strings.TrimSpace(host)
				finding.AffectedHosts = append(finding.AffectedHosts, host)
			}
		}

		findings = append(findings, finding)
	}

	return findings
}

func generateReport(findings []ScanFinding) string {
	// Generate a user-friendly report using the extracted findings
	reportTemplate := `
Scan Report:

{{range $index, $finding := .}}
Finding {{$index}}:
	File: {{$finding.File}}
	Line: {{$finding.Line}}
	Vulnerability: {{$finding.Vulnerability}}
	Message: {{$finding.Message}}
	Affected Hosts: 
	{{- range $finding.AffectedHosts}}
		- {{$host := .}}{{$host}}
	{{- end}}
{{- end}}
`

	// Create a template using the reportTemplate
	tmpl, err := template.New("report").Parse(reportTemplate)
	if err != nil {
		log.Fatal(err)
	}

	// Execute the template with the findings and capture the output in a string
	var report strings.Builder
	err = tmpl.Execute(&report, findings)
	if err != nil {
		log.Fatal(err)
	}

	return report.String()
}

func saveReportToFile(report, filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(report)
	if err != nil {
		return err
	}

	return nil
}
